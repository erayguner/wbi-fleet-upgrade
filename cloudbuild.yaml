# Cloud Build Configuration for Vertex AI Workbench Fleet Upgrade/Rollback
#
# This configuration provides a production-ready CI/CD pipeline for WBI operations with:
# - Comprehensive input validation and error handling
# - Upgrade and rollback operations via _OPERATION substitution
# - Safe-by-default: dry-run mode enabled unless explicitly disabled
# - Structured JSON logging for Cloud Logging integration
# - Parallel execution control to prevent API throttling
# - Dedicated service account for least-privilege access
# - Automatic artifact archiving to Cloud Storage
# - Health checks and operation monitoring
#
# Quick Start:
#   # Dry-run upgrade (safe to test)
#   gcloud builds submit --config=cloudbuild.yaml \
#     --substitutions=_PROJECT_ID=my-project,_LOCATIONS="europe-west2-a"
#
#   # Actual upgrade with rollback protection
#   gcloud builds submit --config=cloudbuild.yaml \
#     --substitutions=_PROJECT_ID=my-project,_LOCATIONS="europe-west2-a",\
#_DRY_RUN=false,_ROLLBACK_ON_FAILURE=true
#
# Documentation: docs/cloud-build.md
# Operations Guide: OPERATIONS.md

timeout: 7200s  # 2 hours max build time

options:
  logging: CLOUD_LOGGING_ONLY
  machineType: E2_HIGHCPU_8

# Use dedicated service account for least-privilege access
# Create via: terraform -chdir=terraform/cloudbuild-iam apply
serviceAccount: 'projects/${PROJECT_ID}/serviceAccounts/wbi-cloudbuild@${PROJECT_ID}.iam.gserviceaccount.com'

substitutions:
  # Required
  _PROJECT_ID: ''
  _LOCATIONS: ''
  
  # Operation type: 'upgrade' or 'rollback'
  _OPERATION: 'upgrade'
  
  # Safety: dry-run defaults to true
  _DRY_RUN: 'true'
  
  # Optional: specific instance
  _INSTANCE_ID: ''
  
  # Operational parameters
  _MAX_PARALLEL: '10'
  _TIMEOUT: '7200'
  _POLL_INTERVAL: '20'
  _HEALTH_CHECK_TIMEOUT: '600'
  _STAGGER_DELAY: '3.0'
  
  # Upgrade-specific
  _ROLLBACK_ON_FAILURE: 'false'
  
  # Logging
  _JSON_LOGGING: 'true'
  _VERBOSE: 'false'
  
  # Python version (Cloud Build uses python image)
  _PYTHON_VERSION: '3.11'

steps:
  # Step 1: Validate required substitutions and environment
  - id: 'validate-inputs'
    name: 'gcr.io/cloud-builders/gcloud'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -euo pipefail

        # Structured logging helper
        log_json() {
          local severity="$1"
          local message="$2"
          local extras="${3:-}"
          echo "{\"severity\":\"$severity\",\"message\":\"$message\",\"timestamp\":\"$(date -Iseconds)\"${extras:+,$extras}}"
        }

        log_json "INFO" "ðŸ” Validating Cloud Build configuration and inputs"

        # Validation error count
        VALIDATION_ERRORS=0

        # Required: PROJECT_ID
        if [[ -z "${_PROJECT_ID}" ]]; then
          log_json "ERROR" "âŒ VALIDATION FAILED: _PROJECT_ID is required" \
            "\"help\":\"Add --substitutions=_PROJECT_ID=your-project-id\""
          VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
        else
          log_json "INFO" "âœ“ Project ID: ${_PROJECT_ID}"
        fi

        # Required: LOCATIONS
        if [[ -z "${_LOCATIONS}" ]]; then
          log_json "ERROR" "âŒ VALIDATION FAILED: _LOCATIONS is required" \
            "\"help\":\"Add --substitutions=_LOCATIONS=\\\"zone1 zone2\\\"\""
          VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
        else
          # Validate location format
          LOCATION_COUNT=$(echo "${_LOCATIONS}" | wc -w)
          log_json "INFO" "âœ“ Locations: ${_LOCATIONS} (${LOCATION_COUNT} zone(s))"

          # Warn if many locations
          if [[ $LOCATION_COUNT -gt 5 ]]; then
            log_json "WARNING" "âš ï¸  Many locations specified (${LOCATION_COUNT}). Consider batching operations."
          fi
        fi

        # Validate OPERATION
        if [[ "${_OPERATION}" != "upgrade" && "${_OPERATION}" != "rollback" ]]; then
          log_json "ERROR" "âŒ VALIDATION FAILED: _OPERATION must be 'upgrade' or 'rollback', got '${_OPERATION}'" \
            "\"help\":\"Set --substitutions=_OPERATION=upgrade or _OPERATION=rollback\""
          VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
        else
          log_json "INFO" "âœ“ Operation: ${_OPERATION}"
        fi

        # Validate DRY_RUN (warn if disabled)
        if [[ "${_DRY_RUN}" != "true" && "${_DRY_RUN}" != "false" ]]; then
          log_json "ERROR" "âŒ VALIDATION FAILED: _DRY_RUN must be 'true' or 'false', got '${_DRY_RUN}'"
          VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
        elif [[ "${_DRY_RUN}" == "false" ]]; then
          log_json "WARNING" "âš ï¸  DRY_RUN is DISABLED - actual changes will be made!" \
            "\"operation\":\"${_OPERATION}\",\"project\":\"${_PROJECT_ID}\""
        else
          log_json "INFO" "âœ“ Dry-run mode: enabled (safe mode - no changes will be made)"
        fi

        # Validate numeric parameters
        if ! [[ "${_MAX_PARALLEL}" =~ ^[0-9]+$ ]] || [[ "${_MAX_PARALLEL}" -lt 1 ]]; then
          log_json "ERROR" "âŒ VALIDATION FAILED: _MAX_PARALLEL must be a positive integer, got '${_MAX_PARALLEL}'"
          VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
        elif [[ "${_MAX_PARALLEL}" -gt 50 ]]; then
          log_json "WARNING" "âš ï¸  MAX_PARALLEL is very high (${_MAX_PARALLEL}). May cause API throttling."
        fi

        if ! [[ "${_TIMEOUT}" =~ ^[0-9]+$ ]] || [[ "${_TIMEOUT}" -lt 60 ]]; then
          log_json "ERROR" "âŒ VALIDATION FAILED: _TIMEOUT must be >= 60 seconds, got '${_TIMEOUT}'"
          VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
        fi

        # Check for conflicting options
        if [[ "${_OPERATION}" == "rollback" && "${_ROLLBACK_ON_FAILURE}" == "true" ]]; then
          log_json "WARNING" "âš ï¸  ROLLBACK_ON_FAILURE ignored in rollback mode (only applicable to upgrades)"
        fi

        # Exit if validation errors
        if [[ $VALIDATION_ERRORS -gt 0 ]]; then
          log_json "ERROR" "âŒ Validation failed with ${VALIDATION_ERRORS} error(s). Build aborted." \
            "\"help\":\"Review error messages above and fix configuration\""
          exit 1
        fi

        # Success summary
        log_json "INFO" "âœ… All validations passed. Build configuration is valid." \
          "\"operation\":\"${_OPERATION}\",\"project\":\"${_PROJECT_ID}\",\"locations\":\"${_LOCATIONS}\",\"dry_run\":\"${_DRY_RUN}\",\"max_parallel\":\"${_MAX_PARALLEL}\""

        # Additional information
        if [[ "${_INSTANCE_ID}" ]]; then
          log_json "INFO" "ðŸŽ¯ Single instance mode: targeting ${_INSTANCE_ID}"
        else
          log_json "INFO" "ðŸŒ Fleet mode: targeting all instances in specified locations"
        fi

  # Step 2: Setup Python environment and install dependencies
  - id: 'setup-python'
    name: 'python:${_PYTHON_VERSION}-slim'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -euo pipefail
        
        echo '{"severity":"INFO","message":"Setting up Python environment","timestamp":"'"$(date -Iseconds)"'"}'
        
        pip install --quiet --upgrade pip
        pip install --quiet -r requirements.txt
        
        echo '{"severity":"INFO","message":"Python dependencies installed","timestamp":"'"$(date -Iseconds)"'"}'

  # Step 3: Run the operation (upgrade or rollback)
  - id: 'run-operation'
    name: 'python:${_PYTHON_VERSION}-slim'
    entrypoint: 'bash'
    env:
      - 'GCP_PROJECT_ID=${_PROJECT_ID}'
      - 'LOCATIONS=${_LOCATIONS}'
      - 'INSTANCE_ID=${_INSTANCE_ID}'
      - 'DRY_RUN=${_DRY_RUN}'
      - 'MAX_PARALLEL=${_MAX_PARALLEL}'
      - 'TIMEOUT=${_TIMEOUT}'
      - 'POLL_INTERVAL=${_POLL_INTERVAL}'
      - 'HEALTH_CHECK_TIMEOUT=${_HEALTH_CHECK_TIMEOUT}'
      - 'STAGGER_DELAY=${_STAGGER_DELAY}'
      - 'ROLLBACK_ON_FAILURE=${_ROLLBACK_ON_FAILURE}'
      - 'JSON_LOGGING=${_JSON_LOGGING}'
      - 'VERBOSE=${_VERBOSE}'
      - 'BUILD_ID=${BUILD_ID}'
      - 'PROJECT_ID=${PROJECT_ID}'
    args:
      - '-c'
      - |
        set -euo pipefail

        # Structured logging helpers
        timestamp() { date -Iseconds; }

        log_json() {
          local severity="$1"
          local message="$2"
          local extras="${3:-}"
          echo "{\"severity\":\"$severity\",\"message\":\"$message\",\"timestamp\":\"$(timestamp)\",\"build_id\":\"${BUILD_ID}\"${extras:+,$extras}}"
        }

        log_operation_start() {
          log_json "INFO" "ðŸš€ Starting ${_OPERATION} operation" \
            "\"operation\":\"${_OPERATION}\",\"project\":\"${_PROJECT_ID}\",\"dry_run\":\"${_DRY_RUN}\""
        }

        log_operation_end() {
          local exit_code=$1
          local duration=$2
          if [[ $exit_code -eq 0 ]]; then
            log_json "INFO" "âœ… ${_OPERATION} operation completed successfully" \
              "\"duration_seconds\":$duration,\"exit_code\":$exit_code"
          else
            log_json "ERROR" "âŒ ${_OPERATION} operation failed" \
              "\"duration_seconds\":$duration,\"exit_code\":$exit_code"
          fi
        }

        # Install dependencies
        log_json "INFO" "ðŸ“¦ Installing Python dependencies"
        if pip install --quiet -r requirements.txt; then
          log_json "INFO" "âœ“ Dependencies installed successfully"
        else
          log_json "ERROR" "âŒ Failed to install dependencies"
          exit 1
        fi

        # Operation configuration summary
        log_operation_start
        log_json "INFO" "Configuration summary" \
          "\"project\":\"${_PROJECT_ID}\",\"locations\":\"${_LOCATIONS}\",\"dry_run\":\"${_DRY_RUN}\",\"max_parallel\":${_MAX_PARALLEL},\"timeout\":${_TIMEOUT},\"operation\":\"${_OPERATION}\""

        # Build Python arguments
        PYTHON_ARGS=(
          "--project" "${_PROJECT_ID}"
          "--locations" ${_LOCATIONS}
          "--max-parallel" "${_MAX_PARALLEL}"
          "--timeout" "${_TIMEOUT}"
          "--poll-interval" "${_POLL_INTERVAL}"
          "--health-check-timeout" "${_HEALTH_CHECK_TIMEOUT}"
          "--stagger-delay" "${_STAGGER_DELAY}"
        )

        # Add optional instance ID
        if [[ -n "${_INSTANCE_ID}" ]]; then
          PYTHON_ARGS+=("--instance" "${_INSTANCE_ID}")
          log_json "INFO" "ðŸŽ¯ Single instance mode enabled" \
            "\"instance\":\"${_INSTANCE_ID}\""
        else
          log_json "INFO" "ðŸŒ Fleet mode enabled - targeting all instances"
        fi

        # Add dry-run flag
        if [[ "${_DRY_RUN}" == "true" ]]; then
          PYTHON_ARGS+=("--dry-run")
          log_json "WARNING" "ðŸ”’ DRY-RUN MODE: No actual changes will be made"
        else
          log_json "WARNING" "âš ï¸  LIVE MODE: Actual changes will be made!" \
            "\"operation\":\"${_OPERATION}\""
        fi

        # Add operation-specific flags
        if [[ "${_OPERATION}" == "rollback" ]]; then
          PYTHON_ARGS+=("--rollback")
          log_json "INFO" "ðŸ”„ Rollback mode enabled"
        elif [[ "${_ROLLBACK_ON_FAILURE}" == "true" ]]; then
          PYTHON_ARGS+=("--rollback-on-failure")
          log_json "INFO" "ðŸ›¡ï¸  Automatic rollback on failure enabled"
        fi

        # Add verbose flag
        if [[ "${_VERBOSE}" == "true" ]]; then
          PYTHON_ARGS+=("--verbose")
          log_json "INFO" "ðŸ“ Verbose logging enabled"
        fi

        log_json "INFO" "Executing command" \
          "\"command\":\"python3 main.py ${PYTHON_ARGS[*]}\""

        # Execute the operation with timing
        START_TIME=$(date +%s)

        set +e  # Don't exit immediately on error
        python3 main.py "${PYTHON_ARGS[@]}"
        EXIT_CODE=$?
        set -e

        END_TIME=$(date +%s)
        DURATION=$((END_TIME - START_TIME))

        # Log results
        log_operation_end $EXIT_CODE $DURATION

        # Parse and log summary from JSON report if available
        REPORT_FILE="${_OPERATION}-report-"*.json
        if ls $REPORT_FILE 1> /dev/null 2>&1; then
          log_json "INFO" "ðŸ“Š Operation report available" \
            "\"report_file\":\"$REPORT_FILE\""

          # Extract and log key statistics
          if command -v jq &> /dev/null; then
            STATS=$(cat $REPORT_FILE | jq -c '.statistics' 2>/dev/null || echo "{}")
            log_json "INFO" "Operation statistics" \
              "\"statistics\":$STATS"
          fi
        fi

        # Exit with Python script's exit code
        if [[ $EXIT_CODE -ne 0 ]]; then
          log_json "ERROR" "âŒ Build failed. Check logs for details." \
            "\"exit_code\":$EXIT_CODE,\"help\":\"Review Python logs above for error details\""
          exit $EXIT_CODE
        fi

        log_json "INFO" "âœ… Build completed successfully"
        exit 0

  # Step 4: Upload reports to Cloud Storage (optional)
  - id: 'upload-reports'
    name: 'gcr.io/cloud-builders/gsutil'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -euo pipefail
        
        # Only upload if reports exist and a bucket is configured
        REPORT_PATTERN="${_OPERATION}-report-*.json"
        LOG_FILE="workbench-${_OPERATION}.log"
        
        if ls $REPORT_PATTERN 1> /dev/null 2>&1; then
          echo '{"severity":"INFO","message":"Found report files to archive","timestamp":"'"$(date -Iseconds)"'"}'
          
          # Archive to build artifacts directory
          mkdir -p /workspace/artifacts
          cp $REPORT_PATTERN /workspace/artifacts/ 2>/dev/null || true
          cp $LOG_FILE /workspace/artifacts/ 2>/dev/null || true
          
          echo '{"severity":"INFO","message":"Reports archived to /workspace/artifacts","timestamp":"'"$(date -Iseconds)"'"}'
        else
          echo '{"severity":"INFO","message":"No report files found to archive","timestamp":"'"$(date -Iseconds)"'"}'
        fi

artifacts:
  objects:
    location: 'gs://${PROJECT_ID}-cloudbuild-artifacts/wbi-fleet-upgrade/${BUILD_ID}/'
    paths:
      - 'upgrade-report-*.json'
      - 'rollback-report-*.json'
      - 'workbench-upgrade.log'
      - 'workbench-rollback.log'
